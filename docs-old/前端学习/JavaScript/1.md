## 脚本语言属于解释型语言

不需要编译，运行过程中由js解释器（js引擎）逐行来解释并执行



![编译型语言额解释型语言的区别](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/6OxqSqWBqsL1iamQCBKC7CTsEVibiayzs00xkgaoYDu8mbPyN22dbPO4ficeRtOkBWfeicPibrAQ3uuJH3Xy6VdSicdFQ/640?wx_fmt=jpeg)

**编译型语言写的程序在被执行之前，需要一个专门的编译过程**，把程序编译成为机器语言的文件，比如exe文件，以后要运行的话就不用重新翻译了，直接使用编译的结果就行了（exe文件），因为翻译只做了一次，**运行时不需要翻译**，所以编译型语言的程序执行效率高。

  解释则不同，解释性语言的程序不需要编译，省了道工序，**解释性语言在运行程序的时候才翻译**，比如解释性basic语言，专门有一个解释器能够直接执行basic程序，每个语句都是执行的时候才翻译。这样解释性语言每执行一次就要翻译一次，效率比较低。



**HTML/CSS  标记语言——描述类语言**

**JS  脚本语言——编程类语言**





## 浏览器执行JS过程

浏览器分成2部分，渲染引擎和JS引擎

* **渲染引擎**：用来解析HTML和CSS，俗称**内核**，比如Chrome浏览器的**blink**，Safari的**webkit**
* **JS引擎**：也称为JS解释器，用来读取网页中的JavaScript代码，对其处理后运行，比如Chrome的**V8**

> JS引擎执行代码时，是**逐行解释**每一句源码（转换为机器语言），然后由计算机去执行，所以JavaScript语言**归为脚本语言**
>
> **所以一旦报错，错误的语句之后的语句都不会继续执行**





## JavaScript的三个组成

### JS基础阶段

1. JavaScript语法：**ECMAScript**

基础为后面交互效果做铺垫

### Web APIs 阶段

2. 页面文档对象模型：**DOM**

3. 浏览器对象模型：**BOM**

Web APIs是JS 的应用，大量使用JS基础语法做交互效果

* **ECMAScript**是由ECMA国际（原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为JavaScript（网景公司）或JScript（微软公司），但后2者是ECMAScript语言的实现和扩展

  ECMAScript规定了JS的编程语法和基础核心知识

* **DOM**：Document Object Model，文档对象模型。是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过DOM提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）

* **BOM**：Browser Object Model，浏览器对象模型。它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等等。





## JavaScript的三种引入方式

### 行内引入:

<开始标签 **on+事件类型**=**“js代码”**></结束标签>

~~~html
<body>
<input type="button" οnclick="alert('行内引入')" value="button" name="button">
<button οnclick="alert(123)">点击我</button>
</body>
~~~



### 内嵌引入：

在head**或**body中，定义**script标签**，然后在script标签里面写js代码

~~~html
    <script>
        alert("这是js的内部引入");
    </script>
~~~



### 外部引入（推荐使用）：

先定义外部js文件（**.js后缀**的文件，不是.JavaScript哦）

然后在head**或者**body（**一般在body里**）中，添加以下代码

~~~html
  <script  type="text/javascript" src="js/xxxxx.js"></script>
~~~

使用外部引入时，**script标签里面不要再写内容了**！那是内嵌引入！



### 注意

* script标签一般定义在head或**body中**

  > 但最好**写在body里**
  >
  > 
  >
  > 在head内的js一般要先执行完后，才开始渲染body页面。为了避免head引入的js脚本阻塞流浪器中主解析引擎对dom的解析工作，对dom的渲染，一般原则是：样式在前面，dom文档，脚本在最后面。遵循**先解析再渲染再执行script**这个顺序。
  >
  > 

* 三种方法不要混搭使用，如果外部引入了，那你的内嵌将会失效

* **HTML引号常用双引号，JS的引号常用单引号**

* 外部的JS文件，它具有**维护性高、可缓存(加载一次，无需加载)、方便未来扩展、复用性高**等特点





## JS输入输出语句



| 方法                                             | 说明                                                         | 归属   |
| ------------------------------------------------ | ------------------------------------------------------------ | ------ |
| prompt('提示语')                                 | 览器弹出输入框，用户可以输入;**该表达式的值即用户输入的值（字符串型，求和时记得转换）** | 浏览器 |
| alert('提示语')                                  | 浏览器弹出警示框                                             | 浏览器 |
| console.log(变量/表达式)           [控制台.日志] | 浏览器**控制台**打印输出信息（给程序员**调试**用的）         | 浏览器 |





## 变量

### 什么是变量

通俗：把变量理解为一个存放数据的**容器**，我们**通过变量名**获取、修改数据

本质：变量是程序在内存中申请的一块用来存放数据的空间



### 变量的使用

* **声明**变量 ：`var xxx;`

  **var**是一个JS关键字，用来声明变量（variable 变量）。声明变量后，计算机自动为变量分配内存空间

* 给变量**赋值**：`xxx = 10;`

* 变量的**初始化**：`var myname = 'Times';`

* **多个变量**初始化，用**逗号**隔开(不是分号，最后一个才用分号)

  ~~~javascript
  var age = 10,
  	name = ‘times’,
  	sex = 1；
  ~~~

* 不声明，直接使用，报错

* **只声明，不赋值**，该变量的值为**undefined**（未定义的）

* 不声明，直接赋值（不用var，直接`xxx =10`），该变量变成**全局变量**





## 数据类型

**为什么需要数据类型**

在计算机中，不同的数据所需要占用的存储空间是不同的，为了便于把数据分成所需内存大小不同的数据，充分利用存储空间，于是定义了不同的数据类型。



**JS中变量的数据类型**

* JavaScript是一种**弱类型或者说动态语言**。这意味着它**不用提前声明变量的类型**。

* 在程序运行过程中，数据类型**由赋予的值来判断**，运行完毕后，变量就确定了数据类型

* JS是动态语言，它的数据类型是可以变化的（多次对一个变量赋值）



### 数据类型的分类



#### **简单数据类型**（值类型）

（Number、String、Boolean、Undefined、Null）

存储的是**值本身**

* null返回的类型是object（历史遗留问题），以后如果有个变量打算存做对象，但还没想好放啥，就可以给个null



| 简单数据类型 | 说明                                                         | 默认值    | 控制台颜色 |
| ------------ | ------------------------------------------------------------ | --------- | ---------- |
| Number       | 数字型；包含整型和浮点型；                                   | 0         | 蓝色       |
| String       | 字符串型；如"小明"（JS的字符串都带引号）；**prompt()传入的值属于字符型** | ""        | 黑色       |
| Boolean      | 布尔类型；true(1)、false(0)                                  | false     | 深蓝色     |
| Undefined    | var a ;声明了变量，但不给值                                  | undefined | 灰色       |
| Null         | var a = null ;声明了变量，给空值                             | null      | 灰色       |





#### **复杂数据类型**（引用类型）

（使用new关键字创建的对象，如Object 、Array、Date等等）

存储的是**地址(引用)**



#### 堆和栈

JS中没有堆栈概念，但是通过堆栈的方式会更容易理解代码

|      | 存放内容                                    |
| ---- | ------------------------------------------- |
| 堆   | 复杂数据类型的**值**                        |
| 栈   | 简单数据类型的**值**/**复杂数据类型的地址** |



#### 简单数据类型传参

函数的形参也可看做是一个变量，当我们传一个变量给形参时，其实是把变量的栈里面保存**值复制**一份给形参，所以在函数内部对形参无论怎么修改，都**不会影响到外部的变量**

~~~js
function fn(a){
    a++;
    console.log(a);
}
var x = 10;
fn(x);
console.log(x);
// 结果是先打印11（a） 后打印10（x）
~~~



#### 复杂数据类型传参

当我们传一个复杂数据类型给形参时，其实是把变量的栈里面保存的**堆地址复制**一份给形参，所以实参和形参在栈里面保存的都是同一个堆的地址，所以会**互相影响**

~~~js
function Person(n){
    this.name = n;
}
function f1(x){
    console.log(x.name);	// 2.这个输出'刘德华'
    x.name = '张学友'；
    console.log(x.name);	// 3.这个输出'张学友'
}

var p = new Person('刘德华');
console.log(p.name);		// 1.这个输出'刘德华'
f1(p);
console.log(p.name);		// 4.这个输出'张学友'
~~~





#### 数字型

* 前面**加0**八进制，**加0x**十六进制

* JS中数字型的最大和最小值：

  **Number.MAX_VALUE**		**Number.MIN_VALUE**

  ~~~~javascript
  console.log(Number.MAX_VALUE);
  console.log(Number.MIN_VALUE);
  ~~~~

* 数字型中的3个特殊值

  1. `Infinity`，代表无穷大，大于任何数值

  2. `-Infinity`，代表无穷小，小于任何数值

  3. **`NaN`，Not a number，代表非数值**

     比如：console.log( **'你好' - 100** )；

     **可用 `isNaN()`这个方法判断是否为非数值**



> **Infinity  和  Number.MAX_VALUE  到底谁更大？**
>
> Infinity > Number.MAX_VALUE 为true
>
> Infinity = Number.MAX_VALUE 也为true
>
> Infinity < Number.MAX_VALUE 为false
>
> 
>
> **Infinity 不管你再怎么加倍，都和Infinity相等**
>
> **Number.MAX_VALUE*2之后会变成Infinity**



####  字符串型

* 字符串型数据一定要加双引号或者单引号（因为HTML里面的属性值使用的是双引号，为方便区分，建议使用**单引号**）

  > 'OK'、123'、'true'   都是字符串型数据
  >
  > 只要你有单引号，都是字符串型，不管你里面装的是数字还是字符



##### **字符串嵌套**

可以用单引号嵌套双引号，或者用双引号嵌套单引号（**外单内双，外双内单**）



##### 字符串转义字符

| 转义符 | 解释说明                 |
| ------ | ------------------------ |
| \n     | 换行符，n是newline的意思 |
| \t     | tab 缩进                 |
| \b     | 空格，b是blank的意思     |
| \\\    | 反斜杠                   |
| \\'    | 单引号                   |
| \\"    | 双引号                   |



##### 字符串长度判断xxx.length

~~~javascript
var abc = 'my name is andy';
console.log(abc.length);// 15
~~~



##### 字符串拼接 +

* 多个字符串之间使用+进行拼接；

* **如果2个加数里面没有字符串，那加号就是数学运算**；

  按顺序执行代码，**直到加数里面含有含有字符串**，会**把另外一个加数变成字符串**，然后拼接输出一个新的字符串；然后继续往下，按照以上规则执行代码：

~~~~js
var v = 'abc';console.log(v.length + 1 + '2');//输出 '42';先是3+1数学运算成4，然后拼接4+'2'console.log('2'+2*2);;//输出 '24',同理，因为乘法优先，所以2*2=4，然后拼接。
~~~~



* 字符串拼接**常用于和变量进行拼接**，因为变量可以方便地修改里面的值；

  先把整串字符串打完整，然后在**需要插入变量的地方打2个引号和2个加号**

~~~javascript
var age = 18;console.log('小明今年' + age + '岁了')
~~~

​	

#### 布尔型

true表示1，false表示0



#### undefined

产生方式：

* 定义，但未赋值
* 定义，但赋值为undefined

#### null

产生方式：

* 定义，但赋值为null



#### undefined和null的区别

**先明确一点：和数字相加（无字符串）只有2种结果，要么是数字，要么是NaN**

* undefined和数字相加，**输出NaN（非数）**

* null和数字相加，相当于0+数字，**输出另外一个加数**

> 可以理解为**null有数据类型**，但目前还不清楚是哪种，所以加了数字型就一起被同化成数字型；
>
> **但undefined是连数据类型都没有。**



|           | 数据类型             | 含义   |
| --------- | -------------------- | ------ |
| NaN       | 数字型               | 非数字 |
| null      | 有数据类型，但不知道 | 空     |
| undefined | 无数据类型           | 未定义 |





### typeof()检测变量的数据类型

因为它本身是运算符，它不是函数，使用时可以不加小括号，直接用空格接变量。



### 数据类型的转换



#### 转换为字符串

| 方式                         | 案例               |
| ---------------------------- | ------------------ |
| .toString()，括号别丢        | xxx.toString()     |
| String()函数，强制转换       | String(xxx)        |
| **加号拼接字符串，隐式转换** | xxx + '我是字符串' |



#### 转换为数字型

| 方式                      | 说明                 | 案例                      |
| ------------------------- | -------------------- | ------------------------- |
| `parseInt('xxx')`函数▲    | 将变量转成整数       | `parseInt('12em34')`      |
| `parseFloat('xxx')`函数▲  | 将变量转成浮点数     | `parseFloat('12.34em34')` |
| Number('xxx')强制转换函数 | 将变量转成数值型     | Number('12')              |
| js隐式转换( - * / )       | 利用算术运算隐式转换 | '12'-0                    |



* parseInt('xxx') 和 parseFloat('xxx')的转换：

  parseInt('12em34')，输出12

  parseInt('em1234')，输出NaN

  可知：

  parseInt和parseFloat **先判断字符串开头是不是数字，不是数字直接NaN**；

  然后在逐个转换，**转换到非数字就停止**，后面即使还有也不管

* Number('xxx') 和 隐式转换( - * / )  

  1. 整数小数都可转换
  2. 一旦字符串里有非数字，开头都不转换，直接输出NaN



#### 转换为布尔型

| 方式          | 案例            |
| ------------- | --------------- |
| Boolean()函数 | Boolean('xxx'); |

* 代表**空、否定的值会被转换成false**，如 ''、0、NaN、null、undefined
* 其余都会被转换成true

