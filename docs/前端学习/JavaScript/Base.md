## 一、JS引入、输入输出、数据类型

## 脚本语言属于解释型语言

不需要编译，运行过程中由js解释器（js引擎）逐行来解释并执行



![编译型语言额解释型语言的区别](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/6OxqSqWBqsL1iamQCBKC7CTsEVibiayzs00xkgaoYDu8mbPyN22dbPO4ficeRtOkBWfeicPibrAQ3uuJH3Xy6VdSicdFQ/640?wx_fmt=jpeg)

**编译型语言写的程序在被执行之前，需要一个专门的编译过程**，把程序编译成为机器语言的文件，比如exe文件，以后要运行的话就不用重新翻译了，直接使用编译的结果就行了（exe文件），因为翻译只做了一次，**运行时不需要翻译**，所以编译型语言的程序执行效率高。

  解释则不同，解释性语言的程序不需要编译，省了道工序，**解释性语言在运行程序的时候才翻译**，比如解释性basic语言，专门有一个解释器能够直接执行basic程序，每个语句都是执行的时候才翻译。这样解释性语言每执行一次就要翻译一次，效率比较低。



**HTML/CSS  标记语言——描述类语言**

**JS  脚本语言——编程类语言**





## 浏览器执行JS过程

浏览器分成2部分，渲染引擎和JS引擎

* **渲染引擎**：用来解析HTML和CSS，俗称**内核**，比如Chrome浏览器的**blink**，Safari的**webkit**
* **JS引擎**：也称为JS解释器，用来读取网页中的JavaScript代码，对其处理后运行，比如Chrome的**V8**

> JS引擎执行代码时，是**逐行解释**每一句源码（转换为机器语言），然后由计算机去执行，所以JavaScript语言**归为脚本语言**
>
> **所以一旦报错，错误的语句之后的语句都不会继续执行**





## JavaScript的三个组成

### JS基础阶段

1. JavaScript语法：**ECMAScript**

基础为后面交互效果做铺垫

### Web APIs 阶段

2. 页面文档对象模型：**DOM**

3. 浏览器对象模型：**BOM**

Web APIs是JS 的应用，大量使用JS基础语法做交互效果

* **ECMAScript**是由ECMA国际（原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为JavaScript（网景公司）或JScript（微软公司），但后2者是ECMAScript语言的实现和扩展

  ECMAScript规定了JS的编程语法和基础核心知识

* **DOM**：Document Object Model，文档对象模型。是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过DOM提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）

* **BOM**：Browser Object Model，浏览器对象模型。它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等等。





## JavaScript的三种引入方式

### 行内引入:

<开始标签 **on+事件类型**=**“js代码”**></结束标签>

~~~html
<body>
<input type="button" οnclick="alert('行内引入')" value="button" name="button">
<button οnclick="alert(123)">点击我</button>
</body>
~~~



### 内嵌引入：

在head**或**body中，定义**script标签**，然后在script标签里面写js代码

~~~html
    <script>
        alert("这是js的内部引入");
    </script>
~~~



### 外部引入（推荐使用）：

先定义外部js文件（**.js后缀**的文件，不是.JavaScript哦）

然后在head**或者**body（**一般在body里**）中，添加以下代码

~~~html
  <script  type="text/javascript" src="js/xxxxx.js"></script>
~~~

使用外部引入时，**script标签里面不要再写内容了**！那是内嵌引入！



### 注意

* script标签一般定义在head或**body中**

  > 但最好**写在body里**
  >
  > 
  >
  > 在head内的js一般要先执行完后，才开始渲染body页面。为了避免head引入的js脚本阻塞流浪器中主解析引擎对dom的解析工作，对dom的渲染，一般原则是：样式在前面，dom文档，脚本在最后面。遵循**先解析再渲染再执行script**这个顺序。
  >
  > 

* 三种方法不要混搭使用，如果外部引入了，那你的内嵌将会失效

* **HTML引号常用双引号，JS的引号常用单引号**

* 外部的JS文件，它具有**维护性高、可缓存(加载一次，无需加载)、方便未来扩展、复用性高**等特点





## JS输入输出语句



| 方法                                             | 说明                                                         | 归属   |
| ------------------------------------------------ | ------------------------------------------------------------ | ------ |
| prompt('提示语')                                 | 览器弹出输入框，用户可以输入;**该表达式的值即用户输入的值（字符串型，求和时记得转换）** | 浏览器 |
| alert('提示语')                                  | 浏览器弹出警示框                                             | 浏览器 |
| console.log(变量/表达式)           [控制台.日志] | 浏览器**控制台**打印输出信息（给程序员**调试**用的）         | 浏览器 |





## 变量

### 什么是变量

通俗：把变量理解为一个存放数据的**容器**，我们**通过变量名**获取、修改数据

本质：变量是程序在内存中申请的一块用来存放数据的空间



### 变量的使用

* **声明**变量 ：`var xxx;`

  **var**是一个JS关键字，用来声明变量（variable 变量）。声明变量后，计算机自动为变量分配内存空间

* 给变量**赋值**：`xxx = 10;`

* 变量的**初始化**：`var myname = 'Times';`

* **多个变量**初始化，用**逗号**隔开(不是分号，最后一个才用分号)

  ~~~javascript
  var age = 10,
  	name = ‘times’,
  	sex = 1；
  ~~~

* 不声明，直接使用，报错

* **只声明，不赋值**，该变量的值为**undefined**（未定义的）

* 不声明，直接赋值（不用var，直接`xxx =10`），该变量变成**全局变量**





## 数据类型

**为什么需要数据类型**

在计算机中，不同的数据所需要占用的存储空间是不同的，为了便于把数据分成所需内存大小不同的数据，充分利用存储空间，于是定义了不同的数据类型。



**JS中变量的数据类型**

* JavaScript是一种**弱类型或者说动态语言**。这意味着它**不用提前声明变量的类型**。

* 在程序运行过程中，数据类型**由赋予的值来判断**，运行完毕后，变量就确定了数据类型

* JS是动态语言，它的数据类型是可以变化的（多次对一个变量赋值）



### 数据类型的分类



#### **简单数据类型**（值类型）

（Number、String、Boolean、Undefined、Null）

存储的是**值本身**

* null返回的类型是object（历史遗留问题），以后如果有个变量打算存做对象，但还没想好放啥，就可以给个null



| 简单数据类型 | 说明                                                         | 默认值    | 控制台颜色 |
| ------------ | ------------------------------------------------------------ | --------- | ---------- |
| Number       | 数字型；包含整型和浮点型；                                   | 0         | 蓝色       |
| String       | 字符串型；如"小明"（JS的字符串都带引号）；**prompt()传入的值属于字符型** | ""        | 黑色       |
| Boolean      | 布尔类型；true(1)、false(0)                                  | false     | 深蓝色     |
| Undefined    | var a ;声明了变量，但不给值                                  | undefined | 灰色       |
| Null         | var a = null ;声明了变量，给空值                             | null      | 灰色       |





#### **复杂数据类型**（引用类型）

（使用new关键字创建的对象，如Object 、Array、Date等等）

存储的是**地址(引用)**



#### 堆和栈

JS中没有堆栈概念，但是通过堆栈的方式会更容易理解代码

|      | 存放内容                                    |
| ---- | ------------------------------------------- |
| 堆   | 复杂数据类型的**值**                        |
| 栈   | 简单数据类型的**值**/**复杂数据类型的地址** |



#### 简单数据类型传参

函数的形参也可看做是一个变量，当我们传一个变量给形参时，其实是把变量的栈里面保存**值复制**一份给形参，所以在函数内部对形参无论怎么修改，都**不会影响到外部的变量**

~~~js
function fn(a){
    a++;
    console.log(a);
}
var x = 10;
fn(x);
console.log(x);
// 结果是先打印11（a） 后打印10（x）
~~~



#### 复杂数据类型传参

当我们传一个复杂数据类型给形参时，其实是把变量的栈里面保存的**堆地址复制**一份给形参，所以实参和形参在栈里面保存的都是同一个堆的地址，所以会**互相影响**

~~~js
function Person(n){
    this.name = n;
}
function f1(x){
    console.log(x.name);	// 2.这个输出'刘德华'
    x.name = '张学友'；
    console.log(x.name);	// 3.这个输出'张学友'
}

var p = new Person('刘德华');
console.log(p.name);		// 1.这个输出'刘德华'
f1(p);
console.log(p.name);		// 4.这个输出'张学友'
~~~





#### 数字型

* 前面**加0**八进制，**加0x**十六进制

* JS中数字型的最大和最小值：

  **Number.MAX_VALUE**		**Number.MIN_VALUE**

  ~~~~javascript
  console.log(Number.MAX_VALUE);
  console.log(Number.MIN_VALUE);
  ~~~~

* 数字型中的3个特殊值

  1. `Infinity`，代表无穷大，大于任何数值

  2. `-Infinity`，代表无穷小，小于任何数值

  3. **`NaN`，Not a number，代表非数值**

     比如：console.log( **'你好' - 100** )；

     **可用 `isNaN()`这个方法判断是否为非数值**



> **Infinity  和  Number.MAX_VALUE  到底谁更大？**
>
> Infinity > Number.MAX_VALUE 为true
>
> Infinity = Number.MAX_VALUE 也为true
>
> Infinity < Number.MAX_VALUE 为false
>
> 
>
> **Infinity 不管你再怎么加倍，都和Infinity相等**
>
> **Number.MAX_VALUE*2之后会变成Infinity**



####  字符串型

* 字符串型数据一定要加双引号或者单引号（因为HTML里面的属性值使用的是双引号，为方便区分，建议使用**单引号**）

  > 'OK'、123'、'true'   都是字符串型数据
  >
  > 只要你有单引号，都是字符串型，不管你里面装的是数字还是字符



##### **字符串嵌套**

可以用单引号嵌套双引号，或者用双引号嵌套单引号（**外单内双，外双内单**）



##### 字符串转义字符

| 转义符 | 解释说明                 |
| ------ | ------------------------ |
| \n     | 换行符，n是newline的意思 |
| \t     | tab 缩进                 |
| \b     | 空格，b是blank的意思     |
| \\\    | 反斜杠                   |
| \\'    | 单引号                   |
| \\"    | 双引号                   |



##### 字符串长度判断xxx.length

~~~javascript
var abc = 'my name is andy';
console.log(abc.length);// 15
~~~



##### 字符串拼接 +

* 多个字符串之间使用+进行拼接；

* **如果2个加数里面没有字符串，那加号就是数学运算**；

  按顺序执行代码，**直到加数里面含有含有字符串**，会**把另外一个加数变成字符串**，然后拼接输出一个新的字符串；然后继续往下，按照以上规则执行代码：

~~~~js
var v = 'abc';console.log(v.length + 1 + '2');//输出 '42';先是3+1数学运算成4，然后拼接4+'2'console.log('2'+2*2);;//输出 '24',同理，因为乘法优先，所以2*2=4，然后拼接。
~~~~



* 字符串拼接**常用于和变量进行拼接**，因为变量可以方便地修改里面的值；

  先把整串字符串打完整，然后在**需要插入变量的地方打2个引号和2个加号**

~~~javascript
var age = 18;console.log('小明今年' + age + '岁了')
~~~

​	

#### 布尔型

true表示1，false表示0



#### undefined

产生方式：

* 定义，但未赋值
* 定义，但赋值为undefined

#### null

产生方式：

* 定义，但赋值为null



#### undefined和null的区别

**先明确一点：和数字相加（无字符串）只有2种结果，要么是数字，要么是NaN**

* undefined和数字相加，**输出NaN（非数）**

* null和数字相加，相当于0+数字，**输出另外一个加数**

> 可以理解为**null有数据类型**，但目前还不清楚是哪种，所以加了数字型就一起被同化成数字型；
>
> **但undefined是连数据类型都没有。**



|           | 数据类型             | 含义   |
| --------- | -------------------- | ------ |
| NaN       | 数字型               | 非数字 |
| null      | 有数据类型，但不知道 | 空     |
| undefined | 无数据类型           | 未定义 |





### typeof()检测变量的数据类型

因为它本身是运算符，它不是函数，使用时可以不加小括号，直接用空格接变量。



### 数据类型的转换



#### 转换为字符串

| 方式                         | 案例               |
| ---------------------------- | ------------------ |
| .toString()，括号别丢        | xxx.toString()     |
| String()函数，强制转换       | String(xxx)        |
| **加号拼接字符串，隐式转换** | xxx + '我是字符串' |



#### 转换为数字型

| 方式                      | 说明                 | 案例                      |
| ------------------------- | -------------------- | ------------------------- |
| `parseInt('xxx')`函数▲    | 将变量转成整数       | `parseInt('12em34')`      |
| `parseFloat('xxx')`函数▲  | 将变量转成浮点数     | `parseFloat('12.34em34')` |
| Number('xxx')强制转换函数 | 将变量转成数值型     | Number('12')              |
| js隐式转换( - * / )       | 利用算术运算隐式转换 | '12'-0                    |



* parseInt('xxx') 和 parseFloat('xxx')的转换：

  parseInt('12em34')，输出12

  parseInt('em1234')，输出NaN

  可知：

  parseInt和parseFloat **先判断字符串开头是不是数字，不是数字直接NaN**；

  然后在逐个转换，**转换到非数字就停止**，后面即使还有也不管

* Number('xxx') 和 隐式转换( - * / )  

  1. 整数小数都可转换
  2. 一旦字符串里有非数字，开头都不转换，直接输出NaN



#### 转换为布尔型

| 方式          | 案例            |
| ------------- | --------------- |
| Boolean()函数 | Boolean('xxx'); |

* 代表**空、否定的值会被转换成false**，如 ''、0、NaN、null、undefined
* 其余都会被转换成true



## 二、运算符、三元表达式

## 算数运算符



### 浮点数

* 浮点数在算术运算里面经常会产生多余的小数误差

  所以**不要直接拿浮点数去比较是否相等**,因为浮点数在小数点很后面的位置有误差，所以拿去比较的话结果会是false

![image-20210718164000335](https://i.loli.net/2021/07/21/cgrGywCDxhsMv4W.png)



### 前置自增和后置自增

前置自增：该次加减之前生效

后置自增：该次**加减之前**不生效

~~~js
var a = 10;
var b = a++ + ++a ; // e++ =10 , e=11 ; ++e =12 , e=12
console.log(b); //10 + 12 = 22
~~~



## 比较运算符

比较运算符，其**返回值一定是0或1**

| 运算符名称  | 说明                             | 案例        | 结果  |
| ----------- | -------------------------------- | ----------- | ----- |
| ===     !== | 全等：要求值和**数据类型**都一致 | 37 === '37' | false |



## 逻辑运算符（&& || !）

逻辑运算符是用来**进行布尔值运算**的运算符，其**返回值不一定是0或1！**

因为与&&运算和或||运算有**短路运算**的特性：

当** `表达式1 && 表达式2`        `表达式1 || 表达式2`  **    时

|        | 表达式1为真                    | 表达式1为假                    |
| ------ | ------------------------------ | ------------------------------ |
| 与&&   | 返回表达式2                    | 返回表达式1，**表达式2不执行** |
| 或\|\| | 返回表达式1，**表达式2不执行** | 返回表达式2                    |

而这里面的**表达式**，可以是123、 **''、NaN、null、undefined** 的！



## 赋值运算符

=、+=、-=、\*=、/=、%=



## 运算符优先级

| 优先级 | 运算符                       | 顺序                |
| ------ | ---------------------------- | ------------------- |
| 1      | 小括号                       | ()                  |
| 2      | 一元运算符                   | **先!  后++  --**   |
| 3      | 算数运算符                   | **先\* / % 后 + -** |
| 4      | 关系运算符                   | >  >=  <  <=        |
| 5      | 相等运算符                   | ==  !=  ===  !==    |
| 6      | 逻辑运算符（作为分隔的标志） | **先&&   后\|\|**   |
| 7      | 赋值运算符                   | =                   |
| 8      | 逗号运算符                   | ,                   |



## 多分支语句

### if else if判断条件简化

比如，使用多分支语句（if else if else if...）判断成绩档次时：

第一个`if(score>=90){}`

第二个if就没必要要写90>score>=80了，直接写`if(score>=80){}`

因为肯定是没大于等于90的才会进入下一个if，没必要再判断



### switch

适用情况：

* 当针对变量的**特定值**设置一系列选项时，就可以用switch
* switch是直接根据值跳转到对应选项，所以**执行效率比if高**，因为if是从上往下挨个找的

注意事项：

* 变量需要和case后面的值**全等**才能执行
* 每个case最后跟的**break必须有**，否则会继续执行接下去的case



~~~js
switch(变量){
    case 1:
        执行语句;
    	break;
    case 2:
        执行语句;
    	break;
    case 3:
        执行语句;
    	break;
    default:
        执行语句;
}
~~~





## 三元表达式  ?  :

一元表达式： a++、a--

二元表达式：算数运算

**三元表达式：**

1. `条件表达式 ? 表达式1 : 表达式2`
2. 条件**表达式为1，则执行表达式1**；否则执行表达式2



* 表达式是有返回值的，**如果这个返回值有多处需要使用，一般把它赋值给一个变量；**
* 如果你只要输出的话，那就可以直接写到console.log里面去，少写1行代码

~~~js
console.log(name === '刘德华' ? 1 : 0);
~~~



## 三、断点调试、循环

## 循环

~~~js
for(var i = 0; i<array.length; i++){
	循环体;
}
~~~



## 断点调试

### 步骤

浏览器中按F12 --> **sources** --> 找到需要调试的文件 --> 在**程序的某一行左边行号处单击**，设置断点 --> 按**F5刷新页面，开始调试** --> 按F11可以单步执行

Watch：



## continue和break分别在循环和switch中的比较

### 先给结论：

**continue只对循环有效**，遇到continue，**向上寻找循环**，**重新开始下一次循环**；

**break语句对for 和 switch都有效，**停止本次switch/循环，向上跳出。

|          | 对谁生效     | 作用                                         |
| -------- | ------------ | -------------------------------------------- |
| continue | 循环         | 本次循环剩下的代码不执行，直接跳到下一次循环 |
| break    | 循环、switch | 跳出本次循环/switch                          |

例子：

~~~javascript
<script type="module">
      for (let index = 0; index < 2; index++) {
        switch (index) {
          case 0:
            console.log(0);
            break; // 这里换成continue，这次循环的OK就不会打印
          case 1:
            console.log(1);
            break;
          default:
            break; // 这里换成continue，这次循环的OK就不会打印
        }
        console.log('OK');
      }
    </script>
~~~



continue只对for循环有效，遇到continue直接执行下一次循环，**switch后面的printf("loop is %d\n",i)不会执行；**

break语句对for 和 switch都有效，上述例子，break在switch里面，优先对switch有效，所以遇到break则**直接退出switch语句，后面console.log('OK');语句继续执行。**




## 命名规范

### 标识符命名规范

- 变量、函数的命名必须要**有意义**
- **变量**的名称一般用**名词**
- **函数**的名称一般用**动词**



### 操作符规范

- 操作符左右两侧各保留一个空格



### 注释规范

- 注释符后面接2个空格再写注释





## 四、数组、函数、作用域、预解析

## 数组

数组中可以存放**任意类型**的数据，例如字符串、数字、布尔值等等



### 创建数组的方式

#### 使用new Array()创建数组

~~~js
var 数组名 = new Array(x);		// x表示数组长度，里面有x个空数组元素
var 数组名 = new Array(x,y);	// 等价于[x,y]，里面有2个元素，分别为x和y
~~~

#### 使用数组字面量[]创建数组（常用）

~~~js
var 数组名 =[];
var 数组名 =[10.77,20,true,'小黑'];	// 数组元素之间一定用逗号分隔
~~~



### 访问（获取）某个数组元素

格式：`数组名[索引]`

* 如果访问一个**没有被赋值的数组元素**，返回**undefined**



### 遍历数组（访问全部数组元素）

~~~js
for (var i = 0; i < arr.length; i++) {	// i当索引号使用，所以从0开始
        
}
~~~



**.length在遍历数组做操作的时候，会经常使用到，如：**

### 筛选数组

~~~js
//从arr数组中筛选出大于等于10的数组元素并存入新数组newArr中
var arr = [2,11,6,0,77,25,7];
var newArr = [];
for (var i = 0; i < arr.length; i++) {
    if (arr[i]>= 10) {
        newArr[newArr.length] = arr[i];	// 利用.length就可以少设一个变量
    }
}
console.log(arr);
~~~



### 数组去重

删除数组中的指定元素**（利用!=）**，再**用一个新数组** 装旧数组中想要的数据

~~~js
var arr = [2, 11, 6, 0, 77, 25, 7];
      var newArr = [];
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] != 0) {		//相当于就改了个比较运算符
          newArr[newArr.length] = arr[i];
        }
      }
		console.log(arr);
~~~



### 翻转数组

~~~js
var arr = ['好', '很好', '非常好'];
      var newArr = [];
      for (var i = arr.length -1 ; i >= 0 ; i--) {	//重点是(长度)-1 和 >=
          newArr[newArr.length] = arr[i];
      }
		console.log(newArr);
~~~



### 冒泡排序

~~~js
var arr = [2, 5, 3, 4, 1];
      for (var i = 0; i <= arr.length - 1; i++) {
        for (var j = 0; j < arr.length - i - 1; j++) {
          if (arr[j] > arr[j + 1]) {	// > 从小到大；< 从大到小
            var temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
          }
        }
      }
		console.log(arr);
~~~



### 新增数组元素的方法

#### 修改.length长度

~~~js
arr.length = 5;	// 把数组元素改成5
~~~

#### 修改数组索引

~~~js
var arr = [0, 1];
 	arr[3] = 3;		// 不要再加个var了！
	// arr = 3;		不要直接给数组名赋值，否则会覆盖掉所有数组元素，变成单个变量了
~~~





## 函数



### 用function关键字声明函数（命名函数 function xx）（常用）

* function是声明函数的关键字，全部小写
* 函数名一般是动词

~~~js
function 函数名(形参,形参,形参){
    函数体
    return:xxx
}
~~~



### 用函数表达式声明函数（匿名函数 xx = function）

1. 该方法声明的函数**没有函数名**

2. 用函数表达式声明函数，跟声明变量差不多；只不过声明变量xx里面存的是值，而函数表达式存的是函数
3. **函数表达式必须写在调用函数之前（因为预解析）**

~~~js
var 变量名 = function(){};  // 这个函数没有名字，只有变量名
~~~

.

### 调用函数

~~~~js
函数名(实参);
~~~~

1. 如果 **实参个数 > 形参个数**

   则函数**按顺序**取**形参**的个数

2. 如果 **实参个数 < 形参个数**

   则**缺少的形参**默认为**undefined**，然后进入函数内部处理

3. 因为一般函数名都很长，取用它的返回值时不方便；

   所以一般**定义一个变量，把返回值赋值给该变量**，方便以后操作。



### return 

#### 用return返回值

* `return 形参/表达式`

* return**只能返回一个值**。如果用逗号隔开多个值，**以最后一个为准**

  如果你**想返回多个结果，利用数组**：`return [xxx,xxx,xxx]`

* 函数如果没有return，返回值是undefined



#### 用return终止函数

return除了能返回值外，还能**终止函数**，后面的语句都不执行



### arguments对象

使用场景：

当**不确定会传多少实参**进入函数时，我们很难写形参；这时候可以**不定义形参**，直接在函数内部使用arguments

特点：

1. 只有**函数才有**arguments对象，而且每个函数都已经**内置**好了（不需要再声明）
2. arguments存储了传递到函数的**所有实参**，并以**伪数组的方式存储**

使用案例：

~~~js
function fn() {		// 不必定义形参
        console.log(arguments);
    	console.log(arguments.length);
    	console.log(arguments[2]);
      }
      
      fn(1,3,5,7,9);
~~~



### 伪数组

1. 具有数组的length属性，可以遍历
2. 按索引的方式存储数据（从0开始）
3. **不具有**数组的push()、pop()等方法



### 封装闰年判断函数

~~~js
function fn(year) {
 return year % 400 == 0 || year % 100 !=0 && year % 4 == 0 ? true :false
      }
      
      console.log(fn(2100));	// false
~~~





## 作用域

* 作用域概念：代码名字（变量）在某个范围内起作用和效果；目的是提高程序的可靠性，更重要的是**减少命名冲突**

* js的作用域在ES6之前：全局作用域、局部作用域。（ES6新增块级作用域：在{}内定义的变量不能在外面被使用）

### 全局作用域

整个**script标签**，或者是一个单独的**js文件**

### 局部作用域

在函数内部就是局部作用域，只在函数内部起效果和作用



### 作用域链

内部函数访问外部函数的变量，采取的是链式查找，从内往外（就近原则）来决定取哪个值，这种结构称作作用域链

~~~js
var num = 10;
      function outside() {
        var num = 20;
        function inside() {
          console.log(num);
        }
        inside();		// 定义好函数之后，记得调用
      }
      outside();		// 定义好函数之后，记得调用
~~~





### 全局变量 ▲

1. 在全局作用域下的定义的变量，在全局下都可以使用
2. 注意！如果在**函数内部，没有声明直接赋值的变量也属于全局变量**▲

~~~js
function fn (){
    var a = b = 2;		// b没写var，是全局变量，相当于window.b
    					// a有var 是fn ()的局部变量
}
console.log(b);			// 打印2
console.log(a);			// 报错
~~~

3. 全局变量只有在浏览器关闭的时候才会销毁，比较**占内存资源**



### 局部变量

1. 在局部作用域**（函数内部）定义的变量**，只能在函数内部使用

2. **形参**也是局部变量
3. 局部变量在程序执行完毕后就会销毁，比较**节约内存资源**



## 预解析

JS引擎运行.js分为2步：**预解析**、代码执行

1. 预解析：js引擎会把.js	里面的所有var  和  function  提到当前作用域的最前面
2. 代码执行：按照书写顺序从上往下执行



预解析分为：变量预解析（变量提升）和  函数预解析（函数提升）

1. 变量（包括函数表达式）提升：**只提升变量声明**，**不提升变量赋值**
2. 函数提升：**只提升函数(function)声明**，**不调用函数**
2. **函数会提升到变量之前**▲



**分析方法：**

【声明变量**并不是调到最前面**，而是紧跟在**同级的，原本就有的声明之后**】

~~~js
var a = 18;	// 拆分成 var a; 和 a = 18;
      fun();
      function fun() {
          var b = 9;
          console.log(a);
          console.log(b);
          var a = '123';
      }
// 相当于以下代码
var a;
function fun() {	// 函数并不是调到最前面，而是紧跟在原本就有的声明之后
          	var b;
    		var a; // a并不是调到最前面，而是紧跟在原本就有的声明之后
    		b = 9;
          	console.log(a);
          	console.log(b);
          	a = '123';
      }
a = 18 ;
fun();
// 最后打印 undefined 和 9
~~~



面试题：

~~~js
f1();
console.log(c);
console.log(b);
console.log(a); 
function f1() {
        var a = b = c = 9;	//相当于a有声明，局部变量；b和c没声明，是全局变量
        console.log(a);
        console.log(b);
        console.log(c);
      }
                            //输出5个9，最后报错
~~~



## 五、对象



## 什么是对象（object）

保存一个值时，可以用变量；保存多个值（一组值）时，可以用数组；保存**多种数据类型**的信息的时候，可以用**对象**

在JS中，对象是一组**无序的**相关**属性**和**方法**的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。

对象是由属性和方法组成的

* **属性**：事物的**特征（名词）**
* **方法**：事物的**行为（动词）**，可以做什么事



### 变量和属性相比较

|      | 相同点             | 不同点                                           |
| ---- | ------------------ | ------------------------------------------------ |
| 变量 | 都是用来存储数据的 | **单独var声明**并赋值                            |
| 属性 |                    | **不需要var声明**，使用的时候必须是**对象.属性** |

### 函数和方法相比较

|      | 相同点           | 不同点                               |
| ---- | ---------------- | ------------------------------------ |
| 函数 | 都是实现某种功能 | **单独声明**并调用，调用时`函数名()` |
| 方法 |                  | 在对象里面，调用时`对象.方法()`      |





## 创建对象的四种方式



### 1.利用字面量{}创建对象

~~~js
var 对象名 = {
    属性名:属性值,
    方法名:function () {},
};
~~~



1. {}里面的属性或者方法采取**键值对的形式{键:值}**（属性名:属性值）
2. 多个属性或者方法，用**逗号，隔开**

3. **创建方法**的话，冒号后面跟的是一个**匿名函数**(其实属性也是匿名的，都不用var声明)

~~~js
var obj = {						// 对象名叫obj
        uname: "小明",		  // 键值对形式   属性名:属性值
        age: 18,				// 逗号分隔
        sex: "男",
        sayHi: function () {	//创建方法的话，冒号后面跟的是匿名函数
          console.log("hi~");
        },
      };
~~~



### 2.利用new Object()创建对象

~~~js
var 对象名 = new Object();
对象名.属性名 = xxx ；
对象名.方法名 = function () {};
~~~



1. 利用 **=** **逐个**对属性/方法**赋值**
2. 每个属性/方法之间用**分号;隔开**

~~~js
var obj = new Object();
      obj.uname = "小明";
      obj.age = 18;
      obj.sex = "男";
      obj.sayHi = function () {
        console.log("hi~");
      };
~~~





### 3.利用构造函数new 函数名()创建对象【类似new Object()】



#### **3.1 为什么需要构造函数创建对象？**

1. 因为我们一次创建一批对象，里面很多**属性和方法是大量相同**的；

   因此我们可以利用函数的方法，重复这些相同代码，我们就把这个函数称为构造函数。

2. 构造函数，就是把我们对象里面一些相同的**属性和方法抽象出来封装到函数里面**

3. 这个函数里面封装的不是普通代码，而是对象



#### 3.2 构造函数和对象的区别？

* 构造函数：抽象出对象的公共部分封装到函数里，泛指**某一大类**（如明星）
* 对象：具体的，特指的实例（如刘德华）



####  3.3 ▲ 如何声明构造函数

1. 构造函数名，**首字母大写**（语法规范）
2. 构造函数**不需要return**，就可以返回结果

~~~js
function 构造函数名(形参1){			// 方法的形参2不用写在()内
    this.属性名 = 形参1;
    
    this.方法名 = function(形参2){	  //形参2写在方法这里就够了，
        console.log(形参2);			//因为等外部需要调用的时候才会传进来
    };
}

//调用构造函数创建对象
var 对象名 = new 构造函数名(实参1);
~~~

示例：

~~~js
function Star(uname) {
        this.uname = uname;
        this.sing = function (song) {
          console.log(song);
        };
      }

var ldh = new Star('刘德华');
console.log(ldh.uname);
ldh.sing('冰雨');
~~~



#### 3.5 new关键字的执行过程

1. new在内存中创建一个空的对象
2. this就能够指向new创建的空对象
3. 执行构造函数里面的代码，给这个空对象添加属性和方法
4. 返回这个对象（new的执行过程包括了返回，所以**构造函数不需要写return**）



### 4. ▲ 通过class类 constructor 创建对象

- 在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。类抽象了对象的公共部分，它泛指某一大类（class）对象特指某一个，通过类实例化一个具体的对象

和构造函数相比，

声明属性时**多写了内部constructor(形参) **

声明方法时**省去了 this. 和 function**

```js
 // 1. 创建类 class  创建一个类
class Star {
    // 类的共有属性放到 constructor 里面 constructor是 构造器或者构造函数
    constructor(uname, age) {
      this.uname = uname;
      this.age = age;
    }
    //-------------------------------->注意,方法与方法之间不需要添加逗号
    sing(song) {
      console.log(this.uname + '唱' + song);
    }
}

// 2. 利用类创建对象（new）
var ldh = new Star('刘德华', 18);
console.log(ldh); // Star {uname: "刘德华", age: 18}
ldh.sing('冰雨'); // 刘德华唱冰雨
```

 以上代码运行结果:

![](https://i.loli.net/2021/08/13/79xMXYihPepgZ4d.png)

**注意:**

1. 通过class 关键字创建类, **类名**我们还是习惯性定义**首字母大写**
2. 类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象
3. constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数
4. 多个函数方法之间不需要添加逗号分隔
5. **生成实例 new 不能省略**
6. **声明**class类时，后面**不要加**小括号
7. **使用**class类名创建对象时，后面**加**小括号



## 调用对象



### **调用对象的属性（取出回值）：**

方法1：对象名.属性名

~~~js
obj.uname
~~~

方法2：对象名['属性名']

~~~js
obj[uname]
~~~



### **调用对象的方法（进入函数）：**

对象名.方法名()

~~~js
obj.sayHi(实参);
~~~



## 遍历对象for( key in 对象名){}

### 语法格式

~~~js
for( key in 对象名){
    // 对该对象的操作
}
~~~



#### 实例

~~~js
var obj = new Object();
      obj.uname = "小明";
      obj.age = 18;
      obj.sex = "男";
      obj.sayHi = function () {
        console.log("hi~");
      };

for (var key in obj) {			// for in 里面的变量常用key或者k
        console.log(key);		// 输出属性名
        console.log(obj[key]);	// 输出属性值或者是方法
	  };	
~~~

     输出结果:

![image-20210721100832652](https://i.loli.net/2021/07/26/iTqlM5wZ7eVjvfF.png)



## 六、内置对象

## 什么是内置对象

* JS中的对象分为3种：自定义对象、内置对象、浏览器对象
* 前两种是JS基础内容，属于ECMAScript；浏览器对象是JS独有的，在JS API详解

* **内置对象**就是指JS语言**自带的**一些对象,帮助我们快速开发





## 查文档

### MDN

https://developer.mozilla.org/zh-CN/

Mozilla开发者网络（MDN）提供了有关开放网络技术（Open Web）的信息，包括HTML、CSS和万维网及HTML5的API



### 如何学习对象中的方法

1.  查询该方法的**功能**
2. 查看里面**参数**的意义和类型
3. 查看**返回值**的意义和类型
4. 通过demo进行测试





## Math.对象

###  常用属性：

#### Math.PI 圆周率



### **常用方法：**

#### Math.max(参数1,参数2,参数3)  求最大值

* 若参数里面**含有字符串**，则返回**NaN**（有true/false不会，因为相当于1/0）

* 若无参数，返回**-Infinity**



#### Math.abs()  绝对值

* 碰到字符串内全是数字，会隐式转换成数字型
* 一旦字符串内不全是数字，就输出NaN



#### Math.floor() 向下取整

#### Math.ceil() 向上取整

#### Math.round() 四舍五入 就近取整（注意-x.5是-x）

* 注意**负数**，.5是往大的取；比如 -1.5 取 -1



#### Math.radom() 随机数

1. 返回一个随机的**小数**，范围为[0,1)
2. **不需要**输入参数
3. 如果想要其他随机数（比如限定范围、要求整数，那就去MDN查，然后**自己封装成函数，方便使用**）







## 日期Date()对象

日期对象是一个**构造函数**，必须**使用new**来调用创建我们的日期对象



### new Date()

* 如果没有参数，则返回当前系统的当前时间

* 可在()里面输入**字符串**，返回该字符串的日期。

  比如 `'2019-10-1 10:10:8'`	返回	`Tue Oct 01 2019 10:10:08 GMT+0800 (中国标准时间)`

* 在()里面输入**数字**，**月份会 +1**，如`new Date(2019, 10, 1)`返回`Fri Nov 01 2019`



### 日期格式化

| 说明             | 代码               |
| ---------------- | ------------------ |
| 获取当年         | dObj-getFullYear() |
| 获取当月（0-11） | dObj.getMonth()    |
| 获取当天日期     | dObj-getDate()     |
| 获取星期几       | dObj-getDay()      |
| 获取当前小时     | dObj-getHours()    |
| 获取当前分钟     | dObj-getMinutes()  |
| 获取当前秒钟     | dObj-getSeconds()  |



#### 封装日期星期函数

##### 变量.getDay()   星期

返回变量日期的对应星期，0 表示星期天。

▲**注意！在使用getDay()之前要先使用new Date();**

~~~js
var date = new Date();
        var year = date.getFullYear();	// 记住要带括号！！！
        var month = date.getMonth() + 1;
        var dates = date.getDate();
        var arr = ['星期日','星期一','星期二','星期三','星期四','星期五','星期六'] // 因为周日返回0,所以把周日放arr[0]里
        var day = date.getDay();
        console.log('今天是：' + year + '年' + month + '月' + dates + '日 ' + arr[day]);
~~~



##### 输出中文星期

如果想输出类似“星期五”的中文星期，可利用**数组**

~~~js
var date = new Date();
        var year = date.getFullYear();
        var year = date.getMonth() +1;
        var year = date.getDate();
        var arr = ['星期日','星期一','星期二','星期三','星期四','星期五','星期六'] // 因为周日返回0,所以把周日放arr[0]里
        console.log(arr[weekday]);
~~~



#### 封装时分秒函数

~~~js
function getTimer() {	//封装一个函数，返回当前的时分秒，格式08:07:06
        var time = new Date();
        var h = time.getHours();
        h = h < 10 ? "0" + h : h; 		// 确保时分秒都是两位数
        var m = time.getMinutes();
        m = m < 10 ? "0" + m : m;
        var s = time.getSeconds();
        s = s < 10 ? "0" + s : s;
        return h + ":" + m + ":" + s;	// 记得return！
      }
      console.log(getTimer());
~~~



### 获得总毫秒数(时间戳▲  能算相距时间、能获得唯一值)

1. 以下2个函数，都能获得**现在时间距离1970年1月1日的总毫秒数（要得到秒要/1000）**

   `xxx.valueOf()`	和	`xxx.getTime()`

2. **简便方法（常用）**

   **var xxx = +new Date();**	// 多个加号：js在某个数据类型前使用‘+’，这个操作目的是为了**将该数据类型转换为Number类型**，如果转换失败，则返回NaN;

3. H5 新增方法

   Date.now()



### 倒计时案例▲

1. 倒计时即2个时间点相减，但是我们不能直接拿时分秒相减，因为有时候分钟被减数会比减数小
2. 但可以**用时间戳**来做，计算剩余毫秒数，然后转换成时分秒

~~~js
// 声明函数
function countDown(time) {
        var nowTime = +new Date();
        var inputTime = +new Date(time);  // 记住这里括号要传入形参
        var times = (inputTime - nowTime) / 1000;  // 毫秒变秒
        var d = parseInt(times / 60 / 60 / 24);
        d = d < 10 ? "0" + d : d;
        var h = parseInt((times / 60 / 60) % 24);
        h = h < 10 ? "0" + h : h;
        var m = parseInt((times / 60) % 60);
        m = m < 10 ? "0" + m : m;
        var s = parseInt(times % 60);
        s = s < 10 ? "0" + s : s;

        return d + "天" + h + "时" + m + "分" + s + "秒";
      }

// 使用函数
      console.log(countDown('2021-7-22 15:25:00'));
~~~





## 数组Array对象



### 检测是否为数组

#### (1) 变量 instanceof 类型

~~~js
xxx instanceof Array
~~~

#### (2) Array.isArray() 

H5新增的方法，IE9以上支持

~~~js
Array.isArray(xxx)
~~~

以上2种方法，返回true/false



### 添加数组元素（会修改原数组）

| xxx为数组名   | 添加位置 | ()内部                 | 返回值       |
| ------------- | -------- | ---------------------- | ------------ |
| xxx.push()    | 末尾     | 写数组元素（可写多个） | 新数组的长度 |
| xxx.unshift() | 开头     | 写数组元素（可写多个） | 新数组的长度 |



### 删除数组元素（会修改原数组）

| xxx为数组名 | 删除位置 | ()内部                               | 返回值       |
| ----------- | -------- | ------------------------------------ | ------------ |
| xxx.pop()   | 末尾     | 不写参数，一次**只能删一个**数组元素 | 被删除的元素 |
| xxx.shift() | 开头     | 不写参数，一次**只能删一个**数组元素 | 被删除的元素 |



### 改进筛选数组

利用`.push`

~~~js
var arr = [2,11,6,0,77,25,7];
        var newArr = [];
        for (var i = 0; i < arr.length; i++) {
            newArr.push(arr[i]) ;	// 无需再用if判断
        }
~~~





### 改进翻转数组

**.reverse()**

~~~js
var arr = ['好', '很好', '非常好'];
	arr.reverse();
~~~



### 改进排序数组

**.sort(function(){})**

~~~js
var arr = [2, 5, 3, 4, 1];
    arr.sort(function(a,b){
        return a - b;	// a-b升序 ； b-a降序
    });
~~~



### 查找数组索引

|                              | 查找顺序                   | 返回值             | 若找不到该数组元素 |
| ---------------------------- | -------------------------- | ------------------ | ------------------ |
| 数组名.indexOf(数组元素)     | 从前往后                   | 第一个满足的索引号 | 返回 -1            |
| 数组名.lastIndexOf(数组元素) | 从后往前(但索引号不会反的) | 第一个满足的索引号 | 返回 -1            |



~~~js
var arr = ['red',3,3,'blue',]
        console.log(arr.indexOf(3));		// 返回1
        console.log(arr.lastIndexOf(3));	// 返回2
~~~



### 改进数组去重

1. 目标：把旧数组里面不重复的元素选取出来放到新数组中，以达到去重效果
2. 算法：先遍历旧数组，再用旧数组元素查询新数组，如果新数组没有，则添加（利用**.push**），否则不添加
3. 那我们怎么知道新数组中有没有存在该元素？利用**.indexOf**，返回 -1 就代表里面没有该元素

~~~js
function unique(arr){
    var newArr = [];
    for(var i = 0;i < arr.length;i++ ){
        if(newArr.indexOf(arr[i]) === -1){
            newArr.push(arr[i]);
           }
    }
    return newArr;
}
var demo = unique([1,3,'blue',5,7,1,'blue']);
console.log(demo);
~~~



### 数组转换为字符串

|                 | 分隔符                   | 返回值           |
| --------------- | ------------------------ | ---------------- |
| .toString()     | , 逗号                   | 一个拼接的字符串 |
| .join('分隔符') | 根据你写的来，默认是逗号 | 一个拼接的字符串 |





## 字符串String对象



### 基本包装类型

把简单数据类型包装为复杂数据类型，就变成**基本包装类型**，有了属性和方法

~~~js
var str = 'andy';
console.log(str.length);
~~~

按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为js会把基本数据类型包装成复杂数据类型，其执行过程如下：

~~~js
// 1、生成临时变量，把简单类型包装为复杂数据类型
var temp = new String('andy');
// 2、把我们声明的字符变量指向临时变量
str = temp;
// 3、销毁临时变量
temp = null;
~~~



### 字符串的不可变

* 指的是**给字符串赋值时**，虽然看上去内容变了，但其实是内存中新**开辟了一个内存空间**，变量名所指向的地址变了。

* 所以**字符串的所有方法，都不会修改字符串本身**（字符串是不可变的），操作完成**会返回一个新的字符串**。

<img src="https://i.loli.net/2021/07/26/KlNfGj4HAJm3qn9.png" alt="image-20210722194049413" style="zoom:80%;" />



### 根据字符返回位置

|                                                       | 查找顺序                   | 返回值             | 若找不到该字符 |
| ----------------------------------------------------- | -------------------------- | ------------------ | -------------- |
| 字符串名.indexOf(**'要查找的字符',起始的索引号**)     | 从前往后                   | 第一个满足的索引号 | 返回 -1        |
| 字符串名.lastIndexOf(**'要查找的字符',起始的索引号**) | 从后往前(但索引号不会反的) | 第一个满足的索引号 | 返回 -1        |

#### **面试题：查找字符串"oabcoefoxyozzopp"中所有o出现的位置以及次数**

1. 先查找	第一个o出现的位置
2. 然后如果 indexOf 返回的不是 -1 就继续往后找
3. 因为 indexOf 只能找到第一个，所以后面的查找，利用第二个参数，当前索引+1，从而继续往后查找

~~~js
	 var str = "oabcoefoxyozzopp";
     var index = str.indexOf('o');
     var num = 0;
     while (index !== -1) {
       console.log(index);
       num++;
       index = str.indexOf('o',index + 1);
     }
     console.log('o出现的次数是：' + num);
~~~



### 根据位置返回字符▲

|                             | 说明                                                |
| --------------------------- | --------------------------------------------------- |
| 字符串名.charAt(索引号)     | 返回指定位置的字符                                  |
| 字符串名.charCodeAt(索引号) | 返回指定位置的字符的**ASCII码**，判断用户按下哪个键 |
| 字符串名[索引号]【H5】      | 返回指定位置的字符                                  |

#### 统计出现字数最多的字符

1. 利用 .charAt() **遍历字符串**
2. 把**每个字符**都存储给对象，**作为对象的一个属性**，如果对象没有该属性就赋值为1，已经存在就属性值+1
3. **遍历对象**，得到最大值和该字符

~~~js
// 遍历字符串
      var str = "oabcoefoxyozzopp";
      var o = {};	// 声明中间 对象
      for (var i = 0; i < str.length; i++) {
        var chars = str.charAt(i); // chars是字符串的每一个字符
        if (o[chars]) {
          o[chars]++;	// 对象里面已有该属性（字符），就+1
        } else {
          o[chars] = 1; // 对象里面没有该属性（字符），就赋1
        }
      }
// 遍历对象
      var max = 0;
      var ch = ""; 
      for (const k in o) {
        // k得到的是属性名  o[k]得到的是属性值
        if (o[k] > max) {
          max = o[k];
          ch = k;	// 存出现最多次的字符
        }
      }
      console.log("出现最多的字符是" + ch + ",出现了" + max + "次");
~~~



### 拼接以及截取字符串

|                                            | 说明                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| 字符串.concat(str1,str2...)                | str字符串后面拼接str1、str2...                               |
| 字符串.substr(截取的起始索引号,截取的个数) | 从索引号开始截取对应个数的字符  (第二个参数不写的话默认截取到最后) |



### 替换字符串(屏蔽敏感词)

* 数组名.replace('被替换的字符','替换后的字符')

* 每次只会从前往后替换一次

~~~js
// 要求把"oabcoefoxyozzopp"中的o全部换成*号
var str = "oabcoefoxyozzopp";
while(str.indexOf('o') !== -1){
    str.replace('o','*');
}
~~~





### 字符串分割为多个数组元素

|                        | 分隔符                         | 返回值           |
| ---------------------- | ------------------------------ | ---------------- |
| 字符串.split('分隔符') | **根据字符串里的分隔符**来拆分 | 一个拆分后的数组 |

~~~js
var str = 'red&pink&blue';
console.log(str.split('&'));	// 字符串用&隔开，所以填&而不是,
~~~



